# 3-6-3 AI编程工作流程详解

## 🎯 工作流程总览

```
需求输入 → 需求拆解 → 代码生成 → 验收迭代 → 项目交付
   ↓         3动作      2动作      2动作
```

## 📋 第一步：需求拆解（3个动作）

### 动作1：需求清晰描述（10分钟）

#### 模板格式
```
项目名称：[简洁的项目名]
项目类型：[CLI/Web/API/工具/自动化]

核心功能：
1. [功能1] - [详细描述]
2. [功能2] - [详细描述]
3. [功能3] - [详细描述]

技术要求：
- 编程语言：[JavaScript/Python/Go等]
- 框架选择：[React/Express/FastAPI等]
- 数据存储：[JSON/TOML/SQLite等]
- 部署方式：[本地安装/Docker/云端]

性能要求：
- 启动时间：< 3秒
- 内存占用：< 100MB
- 响应时间：< 500ms
- 并发支持：100+用户

安全要求：
- API密钥管理：[方案]
- 配置文件安全：[方案]
- 权限控制：[方案]
- 输入验证：[方案]

验收标准：
- [ ] 功能1正常工作
- [ ] 功能2正常工作
- [ ] 功能3正常工作
- [ ] 性能指标达标
- [ ] 安全措施到位
```

### 动作2：补充详细文档（15分钟）

#### AI助手补充内容
```
## 技术架构设计

### 整体架构
- [架构图描述]
- [模块划分说明]
- [数据流向图]

### 详细功能规格

#### 功能1：[功能名]
**输入**：[数据格式]
**处理**：[处理逻辑]
**输出**：[结果格式]
**异常**：[错误处理]

#### 功能2：[功能名]
[同样详细描述]

### 技术实现方案

#### 文件结构
```
project/
├── src/
│   ├── main.js          # 主程序入口
│   ├── config/          # 配置管理
│   ├── utils/           # 工具函数
│   └── modules/         # 功能模块
├── tests/               # 测试文件
├── docs/                # 文档
├── config.toml          # 配置文件
└── package.json         # 项目配置
```

#### 关键技术点
1. [技术点1] - [实现方案]
2. [技术点2] - [实现方案]
3. [技术点3] - [实现方案]

### 开发计划
1. 第1阶段：基础框架搭建
2. 第2阶段：核心功能实现
3. 第3阶段：测试和优化
```

### 动作3：清空上下文（1分钟）

#### 执行命令
```
/clear  # 清空对话历史
/reset # 重置上下文
```

#### 准备新上下文
- 只保留详细需求文档
- 清除所有之前的对话内容
- 准备专注于代码生成

## 🚀 第二步：生成实现（2个动作）

### 动作4：严格生成（30-60分钟）

#### 提示词模板
```
请严格按照以下详细需求文档实现项目，要求ultra strict和ultra detail：

[粘贴完整的需求规格文档]

生成要求：
1. 严格按照文档中的技术架构和功能规格
2. 使用指定的编程语言和框架
3. 遵循最佳实践和编码规范
4. 包含完整的错误处理
5. 添加适当的日志记录
6. 确保代码的可读性和可维护性
7. 生成所有必要的配置文件
8. 包含使用说明和示例

输出格式：
- 先输出项目结构说明
- 然后逐个文件提供完整代码
- 最后提供使用和部署说明
```

### 动作5：专注执行（持续）

#### 执行原则
- 严格按照需求文档执行
- 不偏离设计架构
- 保持代码质量标准
- 及时确认理解正确

## 🔍 第三步：验收迭代（2个动作）

### 动作6：集中测试（20分钟）

#### 测试检查清单
```
功能测试：
□ 功能1：[测试步骤] - [预期结果]
□ 功能2：[测试步骤] - [预期结果]
□ 功能3：[测试步骤] - [预期结果]

性能测试：
□ 启动时间测试 - < 3秒
□ 内存使用测试 - < 100MB
□ 响应时间测试 - < 500ms

安全测试：
□ API密钥安全性测试
□ 配置文件权限测试
□ 输入验证测试

兼容性测试：
□ Windows兼容性
□ macOS兼容性
□ Linux兼容性

用户体验测试：
□ 安装过程测试
□ 使用流程测试
□ 错误处理测试
```

#### 问题记录格式
```
发现的问题：
1. [问题编号] [严重性: 高/中/低]
   - 问题描述：[详细描述]
   - 重现步骤：[步骤1、2、3]
   - 期望结果：[应该的表现]
   - 实际结果：[实际的表现]

2. [问题编号] [严重性: 高/中/低]
   [同样的格式]
```

### 动作7：批量修复（20分钟）

#### 修复提示词模板
```
基于以下测试结果，请一次性修复所有问题：

[粘贴完整的问题记录列表]

修复要求：
1. 逐个解决所有列出的问题
2. 不要引入新的问题
3. 保持代码的整体一致性
4. 确保修复不影响其他功能
5. 添加相应的测试验证

输出格式：
- 说明每个问题的修复方案
- 提供修改后的完整代码
- 标注修改的具体位置
```

## ⚠️ 三个关键坑点详解

### 坑点1：避免零散修改

#### 错误做法 ❌
```
用户：我发现功能1有个bug
AI：[修复功能1的bug]
用户：功能2也有问题
AI：[修复功能2的bug]
用户：还有个UI问题...
```

#### 正确做法 ✅
```
用户：我测试了整个项目，发现以下问题：
1. 功能1的bug描述
2. 功能2的问题描述
3. UI的体验问题
4. 性能优化建议

请一次性修复所有这些问题。
AI：[提供完整的修复方案]
```

### 坑点2：分离功能与修复

#### 错误做法 ❌
```
用户：修复这个bug的同时，顺便加个新功能
AI：[在修复过程中添加新功能]
结果：新功能引入了新的bug
```

#### 正确做法 ✅
```
用户：先修复这个bug，新功能我们下个版本再加
AI：[专注于bug修复]
用户：bug修复好了，现在开始新功能开发
AI：[专注于新功能开发]
```

### 坑点3：及时回退重生成

#### 识别信号
- 同一个问题修改超过3次
- 每次修改都引入新问题
- 代码质量越来越差
- 修复成本越来越高

#### 回退策略
```
AI：我建议重新生成这个模块
理由：当前修改已经陷入局部优化陷阱
重新生成的好处：
1. 避免技术债务累积
2. 可以采用更好的架构
3. 修复时间更短
4. 代码质量更高

您是否同意重新生成？
```

## 📊 效率统计

### 平均时间分布
- 需求拆解：25分钟
- 代码生成：45分钟
- 验收迭代：40分钟
- **总计：约2小时/完整功能**

### 成功率指标
- 一次通过率：30%
- 二次迭代率：50%
- 多次迭代率：20%

### 质量提升效果
- 需求理解准确率：95%
- 代码质量评分：A-
- 项目完成度：100%
- 用户满意度：90%+

## 🎯 成功案例：配置切换工具

### 项目背景
- 需求：管理多个AI模型配置
- 痛点：手动切换配置文件效率低
- 要求：安全、易用、跨平台

### 实施过程
1. **需求拆解**：明确CLI+GUI双界面设计
2. **代码生成**：基于TOML配置的安全方案
3. **验收迭代**：200多次迭代优化

### 最终成果
- CLI工具：查看、切换、验证功能
- Web GUI：可视化管理界面
- 安全设计：API密钥安全管理
- 跨平台：Windows/macOS/Linux支持

### 技术亮点
- 仅使用Node.js内置模块
- 最小化依赖，提高安全性
- 配置文件加密保护
- 热重载配置更新

这就是经过实战验证的3-6-3 AI编程工作流程，可以帮助您高效完成任何项目开发！